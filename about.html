
  <!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>About - Quantum Labs</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=Rajdhani:wght@500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <!-- Three.js for 3D effects -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <!-- GSAP for advanced animations -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/ScrollTrigger.min.js"></script>
  <style>
    /* Variables - keeping the same vars as your main page */
    :root {
      --white: #FFFFFF;
      --off-white: rgba(255,255,255,0.9);
      --light-gray: rgba(248, 248, 248, 0.1);
      --medium-gray: #E0E0E0;
      --dark-gray: #AAAAAA;
      --primary: #000000;
      --primary-light: #0a0a0a;
      --secondary: #050505;
      --accent: #4f7cff;
      --accent-light: #6a92ff;
      --accent-dark: #3a61d9;
      --accent-2: #ff4f7c;
      --accent-2-light: #ff6a92;
      --space-blue: #1a1a3a;
      --space-purple: #2a1a4a;
      --success: #4CAF50;
      --warning: #FF9800;
      --text-dark: #e0e0e0;
      --text-light: #f5f5f5;
      --text-muted: #888888;
      --box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
      --card-shadow: 0 15px 35px rgba(0, 0, 0, 0.4);
      --easing-standard: cubic-bezier(0.4, 0, 0.2, 1);
      --easing-emphasis: cubic-bezier(0.6, -0.05, 0.25, 1.2);
      --section-transition-height: 120px;
    }
    
    /* Reset */
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    html, body { 
      height: 100%; 
      scroll-behavior: smooth;
      overflow-x: hidden;
    }
    
    body {
      font-family: 'Inter', sans-serif;
      color: var(--text-light);
      background: var(--primary);
      line-height: 1.6;
      overflow-x: hidden;
    }
    
    /* Common Styles */
    .container { 
      max-width: 1440px; 
      margin: 0 auto; 
      padding: 0 40px; 
      z-index: 1;
      position: relative;
    }
    
    section { 
      position: relative; 
      padding: 100px 0; 
      overflow: hidden;
    }
    
    .text-center { 
      text-align: center; 
    }
    
    h1, h2, h3, h4, h5 { 
      font-family: 'Rajdhani', sans-serif; 
      font-weight: 700; 
      color: var(--text-light);
      letter-spacing: -0.02em;
      line-height: 1.2;
    }
    
    h1 { font-size: 72px; }
    h2 { font-size: 48px; margin-bottom: 20px; }
    h3 { font-size: 32px; margin-bottom: 15px; }
    h4 { font-size: 24px; margin-bottom: 12px; }
    h5 { font-size: 20px; margin-bottom: 10px; }
    
    p {
      margin-bottom: 15px;
      font-size: 16px;
      color: var(--text-dark);
    }
    
    .lead {
      font-size: 20px;
      font-weight: 400;
      color: var(--dark-gray);
      max-width: 700px;
      margin: 0 auto 40px;
    }
    
    /* Animated shimmer effect */
    .text-gradient {
      background: linear-gradient(
        90deg,
        var(--accent-dark) 0%,
        var(--accent) 25%,
        var(--accent-light) 50%,
        var(--accent) 75%,
        var(--accent-dark) 100%
      );
      background-size: 200% 100%;
      -webkit-background-clip: text; 
      background-clip: text; 
      color: transparent;
      animation: shimmer 3s linear infinite;
    }
    
    @keyframes shimmer {
      0% { background-position: 0% 50%; }
      100% { background-position: 200% 50%; }
    }
    
    /* Header Styles - Similar to main page for consistency */
    header {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      z-index: 1000;
      transition: all 0.4s ease;
      padding: 20px 0;
      background: transparent;
    }
    
    header.scrolled {
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(15px);
      -webkit-backdrop-filter: blur(15px);
      padding: 15px 0;
      box-shadow: 0 5px 20px rgba(0, 0, 0, 0.4);
    }
    
    .header-container {
      display: flex;
      justify-content: space-between;
      align-items: center;
      max-width: 1440px;
      margin: 0 auto;
      padding: 0 40px;
    }
    
    .logo {
      position: relative;
      text-decoration: none;
      display: flex;
      align-items: center;
    }
    
    .logo-image {
      height: 50px;
      width: auto;
      transition: all 0.3s ease;
    }
    
    .nav-container {
      display: flex;
      align-items: center;
    }
    
    .nav-links { 
      display: flex; 
      gap: 40px; 
      margin-right: 40px;
    }
    
    .nav-links a {
      position: relative; 
      font-weight: 500; 
      color: var(--text-light);
      text-decoration: none; 
      transition: all 300ms var(--easing-standard);
      padding: 8px 0;
    }
    
    .nav-links a::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 2px;
      background: var(--accent);
      transform: scaleX(0);
      transform-origin: right;
      transition: transform 300ms var(--easing-emphasis);
    }
    
    .nav-links a:hover {
      color: var(--accent);
    }
    
    .nav-links a:hover::after {
      transform: scaleX(1);
      transform-origin: left;
    }
    
    /* Mobile Menu */
    .mobile-menu-toggle {
      display: none;
      background: none;
      border: none;
      color: var(--text-light);
      font-size: 24px;
      cursor: pointer;
      z-index: 1001;
    }
    
    .mobile-menu {
      position: fixed;
      top: 0;
      right: 0;
      width: 0;
      height: 100vh;
      background: rgba(0, 0, 0, 0.95);
      backdrop-filter: blur(10px);
      z-index: 1000;
      overflow: hidden;
      transition: width 0.4s var(--easing-emphasis);
    }
    
    .mobile-menu.active {
      width: 100%;
    }
    
    .mobile-menu-content {
      padding: 100px 40px 40px;
      height: 100%;
      opacity: 0;
      transition: opacity 0.4s ease;
      transition-delay: 0.2s;
    }
    
    .mobile-menu.active .mobile-menu-content {
      opacity: 1;
    }
    
    .mobile-nav-links {
      list-style: none;
    }
    
    .mobile-nav-links li {
      margin-bottom: 30px;
      transform: translateX(50px);
      opacity: 0;
      transition: all 0.5s var(--easing-emphasis);
      transition-delay: 0.2s;
    }
    
    .mobile-menu.active .mobile-nav-links li {
      transform: translateX(0);
      opacity: 1;
    }
    
    .mobile-menu.active .mobile-nav-links li:nth-child(2) {
      transition-delay: 0.3s;
    }
    
    .mobile-menu.active .mobile-nav-links li:nth-child(3) {
      transition-delay: 0.4s;
    }
    
    .mobile-menu.active .mobile-nav-links li:nth-child(4) {
      transition-delay: 0.5s;
    }
    
    .mobile-nav-links a {
      font-family: 'Rajdhani', sans-serif;
      font-size: 32px;
      font-weight: 600;
      color: var(--text-light);
      text-decoration: none;
      position: relative;
      display: inline-block;
    }
    
    .mobile-nav-links a::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 2px;
      background: var(--accent);
      transform: scaleX(0);
      transform-origin: right;
      transition: transform 0.4s var(--easing-emphasis);
    }
    
    .mobile-nav-links a:hover {
      color: var(--accent);
    }
    
    .mobile-nav-links a:hover::after {
      transform: scaleX(1);
      transform-origin: left;
    }
    
    .mobile-menu-close {
      position: absolute;
      top: 40px;
      right: 40px;
      background: none;
      border: none;
      color: var(--text-light);
      font-size: 24px;
      cursor: pointer;
    }
    
    /* Keep 3D Galaxy Background (Three.js Container) */
    #galaxy-background {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1;
      background: linear-gradient(to bottom, #000205 0%, #000510 100%);
    }
    
    /* Keep Hero Section with Animated Text */
    .about-hero {
      height: 100vh;
      min-height: 800px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      position: relative;
      overflow: hidden;
    }
    
    /* Keep Glitching Text Effect */
    .glitch-container {
      position: relative;
      font-family: 'Rajdhani', sans-serif;
      font-weight: 700;
      font-size: clamp(40px, 7vw, 72px);
      color: var(--text-light);
      text-transform: uppercase;
      overflow: hidden;
    }
    
    .glitch-text {
      position: relative;
      z-index: 1;
    }
    
    .glitch-text::before,
    .glitch-text::after {
      content: attr(data-text);
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
    
    .glitch-text::before {
      left: 2px;
      text-shadow: -2px 0 var(--accent);
      animation: glitch-animation-1 3s infinite linear alternate-reverse;
      clip-path: polygon(0 0, 100% 0, 100% 45%, 0 45%);
    }
    
    .glitch-text::after {
      left: -2px;
      text-shadow: 2px 0 var(--accent-2);
      animation: glitch-animation-2 2s infinite linear alternate-reverse;
      clip-path: polygon(0 55%, 100% 55%, 100% 100%, 0 100%);
    }
    
    @keyframes glitch-animation-1 {
      0% { transform: translateX(0); }
      80% { transform: translateX(0); }
      85% { transform: translateX(-2px); }
      90% { transform: translateX(2px); }
      95% { transform: translateX(-2px); }
      100% { transform: translateX(0); }
    }
    
    @keyframes glitch-animation-2 {
      0% { transform: translateX(0); }
      80% { transform: translateX(0); }
      85% { transform: translateX(2px); }
      90% { transform: translateX(-2px); }
      95% { transform: translateX(2px); }
      100% { transform: translateX(0); }
    }
    
    /* NEW: Reality Matrix Section */
    .reality-matrix-section {
      padding: 120px 0;
      position: relative;
    }
    
    .matrix-container {
      position: relative;
      background: rgba(10, 10, 25, 0.3);
      backdrop-filter: blur(10px);
      border-radius: 20px;
      height: 600px;
      margin-top: 60px;
      overflow: hidden;
      border: 1px solid rgba(255, 255, 255, 0.05);
      box-shadow: var(--card-shadow);
    }
    
    .matrix-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      height: 100%;
      position: relative;
    }
    
    .matrix-slider {
      position: absolute;
      top: 0;
      left: 50%;
      width: 4px;
      height: 100%;
      background: var(--accent);
      transform: translateX(-50%);
      z-index: 10;
      cursor: col-resize;
    }
    
    .matrix-slider::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 30px;
      height: 30px;
      background: var(--accent);
      border-radius: 50%;
      transform: translate(-50%, -50%);
      box-shadow: 0 0 20px var(--accent);
    }
    
    .matrix-slider::after {
      content: '↔';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: var(--white);
      font-size: 14px;
      font-weight: bold;
    }
    
    .matrix-side {
      height: 100%;
      overflow: hidden;
      position: relative;
    }
    
    .matrix-content {
      padding: 40px;
      height: 100%;
      overflow-y: auto;
      position: relative;
    }
    
    .reality-title {
      font-size: 24px;
      margin-bottom: 20px;
      color: var(--text-light);
      position: relative;
      display: inline-block;
    }
    
    .reality-title::after {
      content: '';
      position: absolute;
      bottom: -5px;
      left: 0;
      width: 100%;
      height: 2px;
      background: currentColor;
    }
    
    .reality-point {
      margin-bottom: 30px;
      position: relative;
      padding-left: 30px;
    }
    
    .reality-point::before {
      content: '';
      position: absolute;
      left: 0;
      top: 5px;
      width: 10px;
      height: 10px;
      border-radius: 50%;
    }
    
    .expectation .reality-title {
      color: var(--accent-2);
    }
    
    .expectation .reality-point::before {
      background: var(--accent-2);
    }
    
    .transformation .reality-title {
      color: var(--accent);
    }
    
    .transformation .reality-point::before {
      background: var(--accent);
    }
    
    /* NEW: Quantum Approach Section with 3D Cube Navigation */
    .quantum-approach {
      padding: 160px 0 120px;
      position: relative;
      overflow: visible;
    }
    
    .approach-intro {
      text-align: center;
      max-width: 800px;
      margin: 0 auto 70px;
      position: relative;
      z-index: 5;
    }
    
    .cube-container {
      position: relative;
      height: 480px;
      perspective: 1000px;
      margin: 0 auto;
      max-width: 800px;
      z-index: 1;
    }
    
    .cube {
      position: relative;
      width: 100%;
      height: 100%;
      transform-style: preserve-3d;
      transition: transform 1.2s cubic-bezier(0.6, -0.05, 0.25, 1.2);
    }
    
    .cube-face {
      position: absolute;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(10, 10, 25, 0.5);
      backdrop-filter: blur(10px);
      border-radius: 20px;
      border: 1px solid rgba(255, 255, 255, 0.05);
      -webkit-backface-visibility: hidden;
      backface-visibility: hidden;
      overflow: hidden;
      padding: 30px;
    }
    
    .cube-face-front { transform: translateZ(240px); }
    .cube-face-back { transform: rotateY(180deg) translateZ(240px); }
    .cube-face-left { transform: rotateY(-90deg) translateZ(240px); }
    .cube-face-right { transform: rotateY(90deg) translateZ(240px); }
    .cube-face-top { transform: rotateX(90deg) translateZ(240px); }
    .cube-face-bottom { transform: rotateX(-90deg) translateZ(240px); }
    
    .cube-content {
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      padding: 10px;
      position: relative;
      z-index: 1;
      max-width: 550px;
      margin: 0 auto;
    }
    
    .cube-nav {
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
      gap: 15px;
      margin-top: 50px;
      position: relative;
      z-index: 5;
    }
    
    .cube-btn {
      background: rgba(255, 255, 255, 0.1);
      color: var(--text-light);
      border: none;
      padding: 10px 20px;
      border-radius: 50px;
      cursor: pointer;
      transition: all 0.3s ease;
      font-family: 'Inter', sans-serif;
      font-weight: 500;
      font-size: 14px;
    }
    
    .cube-btn:hover {
      background: var(--accent);
      transform: translateY(-3px);
    }
    
    .cube-btn.active {
      background: var(--accent);
    }
    
    .cube-icon {
      font-size: 36px;
      color: var(--accent);
      margin-bottom: 15px;
    }
    
    .cube-heading {
      font-size: 24px;
      margin-bottom: 12px;
    }
    
    .cube-description {
      max-width: 520px;
      margin: 0 auto;
      font-size: 15px;
      line-height: 1.5;
    }
    
    /* NEW: Success Ecosystem Section */
    .success-ecosystem {
      padding: 120px 0;
      position: relative;
      overflow: visible;
    }
    
    .ecosystem-container {
      position: relative;
      height: 700px;
      margin-top: 60px;
    }
    
    .ecosystem-canvas-container {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(10, 10, 25, 0.3);
  backdrop-filter: blur(10px);
  border-radius: 20px;
  overflow: hidden;
  border: 1px solid rgba(255, 255, 255, 0.05);
  box-shadow: var(--card-shadow);
  touch-action: none; /* Add this line to fix touch handling */
}
    
    .ecosystem-canvas {
      width: 100%;
      height: 100%;
    }
    
    .ecosystem-tooltip {
      position: absolute;
      padding: 15px 20px;
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(10px);
      border-radius: 10px;
      max-width: 300px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s ease;
      z-index: 100;
    }
    
    .ecosystem-tooltip h4 {
      font-size: 18px;
      margin-bottom: 8px;
      color: var(--accent);
    }
    
    .ecosystem-legend {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 15px;
      margin-top: 20px;
    }
    
    .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 14px;
      color: var(--medium-gray);
    }
    
    .legend-color {
      width: 12px;
      height: 12px;
      border-radius: 50%;
    }
    
  
    
    .gallery-container {
      position: relative;
      margin-top: 60px;
      height: 600px;
    }
    
    .gallery-scene {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(10, 10, 25, 0.3);
  backdrop-filter: blur(10px);
  border-radius: 20px;
  overflow: hidden;
  border: 1px solid rgba(255, 255, 255, 0.05);
  box-shadow: var(--card-shadow);
  touch-action: none; /* Add this line to fix touch handling */
}
    
    .artifact-info {
      position: absolute;
      bottom: 30px;
      left: 30px;
      max-width: 400px;
      background: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(10px);
      padding: 20px;
      border-radius: 10px;
      opacity: 0;
      transform: translateY(20px);
      transition: all 0.5s ease;
    }
    
    .artifact-info.active {
      opacity: 1;
      transform: translateY(0);
    }
    
    .artifact-name {
      font-size: 22px;
      margin-bottom: 10px;
      color: var(--accent);
    }
    
    .artifact-description {
      font-size: 14px;
      line-height: 1.6;
      color: var(--medium-gray);
    }
    
    .nav-hint {
      position: absolute;
      bottom: 30px;
      right: 30px;
      font-size: 14px;
      color: var(--medium-gray);
      background: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(10px);
      padding: 10px 15px;
      border-radius: 10px;
    }
    
    /* Footer (Same as main page for consistency) */
    footer { 
      background: rgba(10, 10, 20, 0.8);
      color: var(--text-light);
      padding: 60px 0 30px;
      position: relative;
      overflow: hidden;
      border-top: 1px solid rgba(255, 255, 255, 0.05);
    }
    
    .footer-content {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      flex-wrap: wrap;
      gap: 40px;
      margin-bottom: 40px;
    }
    
    .footer-left {
      flex: 1;
      min-width: 300px;
    }
    
    .footer-right {
      display: flex;
      gap: 60px;
    }
    
    .footer-about { 
      color: var(--dark-gray);
      margin: 20px 0;
      line-height: 1.6;
      max-width: 350px;
    }
    
    .social-links {
      display: flex;
      gap: 16px;
    }
    
    .social-link {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.05);
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-light);
      transition: all 300ms ease;
      position: relative;
    }
    
    .social-link:hover {
      background: var(--accent);
      transform: translateY(-3px);
    }
    
    .footer-links {
      list-style: none;
    }
    
    .footer-heading {
      font-size: 18px;
      font-weight: 700;
      margin-bottom: 20px;
      color: var(--text-light);
    }
    
    .footer-links li {
      margin-bottom: 12px;
    }
    
    .footer-links a {
      color: var(--dark-gray);
      text-decoration: none;
      transition: color 0.3s ease;
    }
    
    .footer-links a:hover {
      color: var(--accent);
    }
    
    .footer-bottom {
      text-align: center;
      padding-top: 30px;
      border-top: 1px solid rgba(255, 255, 255, 0.05);
      color: var(--text-muted);
      font-size: 14px;
    }
    
    /* Responsive Styles */
    @media (max-width: 992px) {
      .matrix-grid {
        grid-template-columns: 1fr;
        grid-template-rows: 1fr 1fr;
      }
      
      .matrix-slider {
        top: 50%;
        left: 0;
        width: 100%;
        height: 4px;
        transform: translateY(-50%);
        cursor: row-resize;
      }
      
      .cube-container {
        height: 400px;
      }
      
      .cube-face-front { transform: translateZ(200px); }
      .cube-face-back { transform: rotateY(180deg) translateZ(200px); }
      .cube-face-left { transform: rotateY(-90deg) translateZ(200px); }
      .cube-face-right { transform: rotateY(90deg) translateZ(200px); }
      .cube-face-top { transform: rotateX(90deg) translateZ(200px); }
      .cube-face-bottom { transform: rotateX(-90deg) translateZ(200px); }
      
      .nav-links {
        gap: 20px;
      }
      
      .ecosystem-container {
        height: 600px;
      }
    }
    
    @media (max-width: 768px) {
      .container {
        padding: 0 20px;
      }
      
      h1 { font-size: 42px; }
      h2 { font-size: 32px; }
      h3 { font-size: 26px; }
      
      .cube-container {
        height: 320px;
      }
      
      .cube-nav {
        gap: 10px;
        margin-top: 30px;
      }
      
      .cube-btn {
        font-size: 13px;
        padding: 8px 15px;
      }
      
      .cube-face-front { transform: translateZ(180px); }
      .cube-face-back { transform: rotateY(180deg) translateZ(180px); }
      .cube-face-left { transform: rotateY(-90deg) translateZ(180px); }
      .cube-face-right { transform: rotateY(90deg) translateZ(180px); }
      .cube-face-top { transform: rotateX(90deg) translateZ(180px); }
      .cube-face-bottom { transform: rotateX(-90deg) translateZ(180px); }
      
      .cube-icon {
        font-size: 30px;
        margin-bottom: 10px;
      }
      
      .cube-heading {
        font-size: 20px;
        margin-bottom: 10px;
      }
      
      .cube-description {
        font-size: 14px;
        line-height: 1.5;
        max-width: 100%;
      }
      
      .header-container {
        padding: 0 20px;
      }
      
      .nav-links {
        display: none;
      }
      
      .mobile-menu-toggle {
        display: block;
      }
      
      .logo-image {
        height: 90px;
      }
      
      .ecosystem-container,
      .gallery-container {
        height: 450px;
      }
      
      .matrix-content {
        padding: 20px;
      }
      
      .reality-point {
        margin-bottom: 20px;
      }
      
      .footer-content {
        flex-direction: column;
        gap: 30px;
      }
      
      .footer-right {
        width: 100%;
        justify-content: space-between;
      }
    }
    
    @media (max-width: 576px) {
      h1 { font-size: 36px; }
      h2 { font-size: 28px; }
      
      .glitch-container {
        font-size: clamp(32px, 7vw, 42px);
      }
      
      .lead {
        font-size: 16px;
      }
      
      .quantum-approach {
        padding: 130px 0 100px;
      }
      
      .cube-container {
        height: 280px;
      }
      
      .cube-face-front { transform: translateZ(140px); }
      .cube-face-back { transform: rotateY(180deg) translateZ(140px); }
      .cube-face-left { transform: rotateY(-90deg) translateZ(140px); }
      .cube-face-right { transform: rotateY(90deg) translateZ(140px); }
      .cube-face-top { transform: rotateX(90deg) translateZ(140px); }
      .cube-face-bottom { transform: rotateX(-90deg) translateZ(140px); }
      
      .cube-face {
        padding: 20px 15px;
      }
      
      .cube-description {
        font-size: 13px;
        line-height: 1.4;
      }
      
      .cube-nav {
        flex-direction: column;
        align-items: center;
        gap: 8px;
      }
      
      .cube-btn {
        width: 200px;
      }
      
      .nav-links {
        display: none;
      }
      
      .matrix-content {
        padding: 15px;
      }
      
      .reality-point {
        margin-bottom: 15px;
        padding-left: 20px;
      }
      
      .reality-title {
        font-size: 20px;
      }
      
      .ecosystem-container,
      .gallery-container {
        height: 350px;
      }
      
      .footer-right {
        flex-direction: column;
        gap: 30px;
      }
    }
  </style>
</head>
<body>
  <!-- Header - Similar to main page for consistency -->
  <header id="header">
    <div class="header-container">
      <a href="index.html" class="logo">
        <img src="images/quantumlabs.png" alt="Quantum Labs Logo" class="logo-image" style="height: 110px;">
      </a>
      <div class="nav-container">
        <nav class="nav-links">
          <a href="home2.html">Home</a>
          <a href="about.html" class="active">About</a>
          <a href="contact.html">Contact</a>
        </nav>
        <button class="mobile-menu-toggle" id="mobile-menu-toggle">
          <i class="fas fa-bars"></i>
        </button>
      </div>
    </div>
  </header>
  
  <!-- Mobile Menu -->
  <div class="mobile-menu" id="mobile-menu">
    <div class="mobile-menu-content">
      <button class="mobile-menu-close" id="mobile-menu-close">
        <i class="fas fa-times"></i>
      </button>
      <ul class="mobile-nav-links">
        <li><a href="home2.html">Home</a></li>
        <li><a href="about.html">About</a></li>
        <li><a href="contact.html">Contact</a></li>
      </ul>
    </div>
  </div>

  <!-- 3D Galaxy Background (Three.js) - KEEP -->
  <div id="galaxy-background"></div>

  <!-- Hero Section with Animated Text - KEEP -->
  <section class="about-hero" id="about-hero">
    <div class="container">
      <div class="glitch-container">
        <div class="glitch-text" data-text="Our Story">Our Story</div>
      </div>
      <p class="lead">Pioneers in business transformation and growth architecture</p>
      <div id="hero-particles"></div>
    </div>
  </section>

  <!-- NEW: Reality vs. Expectation Split Screen Section -->
  <section class="reality-matrix-section" id="reality-matrix">
    <div class="container text-center">
      <h2>Business <span class="text-gradient">Transformation</span></h2>
      <p class="lead">Swipe to compare conventional approaches with our quantum methodology</p>
      
      <div class="matrix-container">
        <div class="matrix-grid">
          <div class="matrix-side expectation">
            <div class="matrix-content">
              <h3 class="reality-title">Conventional Approach</h3>
              
              <div class="reality-point">
                <h4>Sporadic Growth</h4>
                <p>Traditional business growth relies on periodic campaigns, tactical adjustments, and opportunistic strategies that create unpredictable revenue patterns.</p>
              </div>
              
              <div class="reality-point">
                <h4>Data in Silos</h4>
                <p>Most organizations store critical data in disconnected systems, leading to fragmented insights and missed opportunities for cross-functional optimization.</p>
              </div>
              
              <div class="reality-point">
                <h4>Reactive Adaptations</h4>
                <p>Standard approaches wait for market shifts before adjusting strategy, creating lag time that diminishes competitive advantage and reduces potential revenue.</p>
              </div>
              
              <div class="reality-point">
                <h4>Channel-Centric</h4>
                <p>Traditional growth models organize around marketing channels rather than customer journeys, creating disjointed experiences and inefficient resource allocation.</p>
              </div>
              
              <div class="reality-point">
                <h4>Manual Optimization</h4>
                <p>Teams spend countless hours manually adjusting campaigns and analyzing performance data, leading to delayed decisions and human errors.</p>
              </div>
            </div>
          </div>
          
          <div class="matrix-side transformation">
            <div class="matrix-content">
              <h3 class="reality-title">Quantum Methodology</h3>
              
              <div class="reality-point">
                <h4>Engineered Predictability</h4>
                <p>Our systems architecture creates consistent, scalable growth patterns through algorithmic orchestration of acquisition, conversion, and retention mechanisms.</p>
              </div>
              
              <div class="reality-point">
                <h4>Unified Intelligence Core</h4>
                <p>We integrate all data sources into a centralized neural network that continuously refines customer understanding and business intelligence.</p>
              </div>
              
              <div class="reality-point">
                <h4>Predictive Adaptation</h4>
                <p>Our systems anticipate market shifts using behavioral indicators and automatically adjust strategies before competitors identify the opportunity.</p>
              </div>
              
              <div class="reality-point">
                <h4>Journey Architecture</h4>
                <p>We design growth around complete customer journeys rather than channels, creating seamless experiences that maximize lifetime value and referral potential.</p>
              </div>
              
              <div class="reality-point">
                <h4>Autonomous Systems</h4>
                <p>Our conversion engines continuously self-optimize through machine learning, making thousands of micro-adjustments daily without human intervention.</p>
              </div>
            </div>
          </div>
          
          <div class="matrix-slider" id="matrix-slider"></div>
        </div>
      </div>
    </div>
  </section>

  <!-- NEW: Quantum Approach Section with 3D Cube Navigation -->
  <section class="quantum-approach" id="approach">
    <div class="container">
      <div class="approach-intro">
        <h2>Our <span class="text-gradient">Quantum Approach</span></h2>
        <p class="lead">Explore our growth methodology</p>
      </div>
      
      <div class="cube-container">
        <div class="cube" id="approach-cube">
          <!-- Front Face: Data Systems -->
          <div class="cube-face cube-face-front">
            <div class="cube-content">
              <div class="cube-icon"><i class="fas fa-database"></i></div>
              <h3 class="cube-heading">Data Unification</h3>
              <p class="cube-description">
                We integrate all customer data into a single ecosystem that powers decisions. Our connectors bring together disparate systems to create a unified intelligence layer that strengthens with every interaction.
              </p>
            </div>
          </div>
          
          <!-- Back Face: Revenue Systems -->
          <div class="cube-face cube-face-back">
            <div class="cube-content">
              <div class="cube-icon"><i class="fas fa-chart-line"></i></div>
              <h3 class="cube-heading">Revenue Architecture</h3>
              <p class="cube-description">
                Beyond traditional funnels, we design complete revenue systems that orchestrate acquisition, conversion, upselling, and retention mechanisms to create predictable, scalable growth.
              </p>
            </div>
          </div>
          
          <!-- Right Face: AI Implementation -->
          <div class="cube-face cube-face-right">
            <div class="cube-content">
              <div class="cube-icon"><i class="fas fa-robot"></i></div>
              <h3 class="cube-heading">Cognitive Systems</h3>
              <p class="cube-description">
                Our AI implementation creates smart business systems that optimize your customer journey and messaging, identifying growth opportunities before competitors can respond.
              </p>
            </div>
          </div>
          
          <!-- Left Face: Customer Journey -->
          <div class="cube-face cube-face-left">
            <div class="cube-content">
              <div class="cube-icon"><i class="fas fa-route"></i></div>
              <h3 class="cube-heading">Journey Architecture</h3>
              <p class="cube-description">
                We optimize the complete customer journey across all touchpoints, creating seamless experiences aligned with natural decision-making patterns to eliminate friction points.
              </p>
            </div>
          </div>
          
          <!-- Top Face: Growth Stack -->
          <div class="cube-face cube-face-top">
            <div class="cube-content">
              <div class="cube-icon"><i class="fas fa-layer-group"></i></div>
              <h3 class="cube-heading">Growth Stack</h3>
              <p class="cube-description">
                We build technology stacks optimized for your growth goals, integrating specialized tools for behavioral analytics, conversion optimization, and customer retention.
              </p>
            </div>
          </div>
          
          <!-- Bottom Face: Measurement Framework -->
          <div class="cube-face cube-face-bottom">
            <div class="cube-content">
              <div class="cube-icon"><i class="fas fa-ruler-combined"></i></div>
              <h3 class="cube-heading">Quantum Metrics</h3>
              <p class="cube-description">
                We implement advanced measurement frameworks beyond traditional KPIs to track true growth drivers and enable precision resource allocation for maximum ROI.
              </p>
            </div>
          </div>
        </div>
      </div>
      
      <div class="cube-nav">
        <button class="cube-btn active" data-face="front">Data Unification</button>
        <button class="cube-btn" data-face="back">Revenue Architecture</button>
        <button class="cube-btn" data-face="right">Cognitive Systems</button>
        <button class="cube-btn" data-face="left">Journey Architecture</button>
        <button class="cube-btn" data-face="top">Growth Stack</button>
        <button class="cube-btn" data-face="bottom">Quantum Metrics</button>
      </div>
    </div>
  </section>

  <!-- NEW: Success Ecosystem Map -->
  <section class="success-ecosystem" id="impact">
    <div class="container text-center">
      <h2>Our <span class="text-gradient">Impact Ecosystem</span></h2>
      <p class="lead">Explore how our projects and methodologies interconnect to create transformative results</p>
      
      <div class="ecosystem-container">
        <div class="ecosystem-canvas-container">
          <canvas id="ecosystem-canvas" class="ecosystem-canvas"></canvas>
        </div>
        <div class="ecosystem-tooltip" id="ecosystem-tooltip"></div>
      </div>
      
      <div class="ecosystem-legend">
        <div class="legend-item">
          <div class="legend-color" style="background: #4f7cff;"></div>
          <span>Revenue Systems</span>
        </div>
        <div class="legend-item">
          <div class="legend-color" style="background: #ff4f7c;"></div>
          <span>Client Success</span>
        </div>
        <div class="legend-item">
          <div class="legend-color" style="background: #4CAF50;"></div>
          <span>Methodologies</span>
        </div>
        <div class="legend-item">
          <div class="legend-color" style="background: #FF9800;"></div>
          <span>Technology</span>
        </div>
      </div>
    </div>
  </section>

 
  </section>

  <!-- Footer (Same as main page for consistency) -->
  <footer>
    <div class="container">
      <div class="footer-content">
        <div class="footer-left">
          <a href="#" class="logo">
            <img src="images/quantumlabs.png" alt="Quantum Labs Logo" class="logo-image" style="height: 110px;">
          </a>
          <p class="footer-about">
            Engineering predictable growth systems for visionary businesses. We transform how companies acquire customers and scale revenue.
          </p>
          <div class="social-links">
            <a href="#" class="social-link"><i class="fab fa-linkedin-in"></i></a>
            <a href="#" class="social-link"><i class="fab fa-twitter"></i></a>
            <a href="https://www.instagram.com/quantumlabshq?igsh=MWw5cTN6bWd0YXMyeQ%3D%3D" class="social-link"><i class="fab fa-instagram"></i></a>
            <a href="#" class="social-link"><i class="fab fa-facebook-f"></i></a>
          </div>
        </div>
        <div class="footer-right">
          <div class="footer-column">
            <h4 class="footer-heading">Quick Links</h4>
            <ul class="footer-links">
              <li><a href="home.html">Home</a></li>
              <li><a href="about.html">About</a></li>
            
              <li><a href="contact.html">Contact</a></li>
            </ul>
          </div>
          <div class="footer-column">
            <h4 class="footer-heading">Contact</h4>
            <ul class="footer-links">
              <li><a href="mailto:Zakeriye@quantumlabshq.com">Zakeriye@quantumlabshq.com</a></li>
              <li><a href="tel:+447956487424">+44 7956487424 </a></li>
              <li><a href="#">Birmingham, United Kingdom</a></li>
            </ul>
          </div>
        </div>
      </div>
      <div class="footer-bottom">
        <p>© 2024 Quantum Labs. All rights reserved. </p>
      </div>
    </div>
  </footer>

  <!-- JavaScript for all interactive elements -->
  <script>
    // Initialize all interactive elements when the DOM is loaded
    document.addEventListener('DOMContentLoaded', function() {
      // Initialize header scroll effect
      initializeHeader();
      
      // Initialize Mobile Menu
      initializeMobileMenu();
      
      // Initialize 3D Galaxy Background
      initializeGalaxyBackground();
      
      // Initialize Reality Matrix
      initializeRealityMatrix();
      
      // Initialize Quantum Approach Cube
      initializeApproachCube();
      
      // Initialize Success Ecosystem Map
      initializeEcosystem();
      
      
    });
    
    // Initialize Mobile Menu
    function initializeMobileMenu() {
      const menuToggle = document.getElementById('mobile-menu-toggle');
      const menuClose = document.getElementById('mobile-menu-close');
      const mobileMenu = document.getElementById('mobile-menu');
      
      if (menuToggle && menuClose && mobileMenu) {
        menuToggle.addEventListener('click', () => {
          mobileMenu.classList.add('active');
          document.body.style.overflow = 'hidden'; // Prevent scrolling when menu is open
        });
        
        menuClose.addEventListener('click', () => {
          mobileMenu.classList.remove('active');
          document.body.style.overflow = ''; // Restore scrolling
        });
        
        // Close menu when clicking a menu item
        const menuLinks = document.querySelectorAll('.mobile-nav-links a');
        menuLinks.forEach(link => {
          link.addEventListener('click', () => {
            mobileMenu.classList.remove('active');
            document.body.style.overflow = ''; // Restore scrolling
          });
        });
      }
    }
    
    // 1. HEADER SCROLL EFFECT
    function initializeHeader() {
      window.addEventListener('scroll', function() {
        const header = document.getElementById('header');
        
        if (window.scrollY > 50) {
          header.classList.add('scrolled');
        } else {
          header.classList.remove('scrolled');
        }
      });
    }
    
    // 2. INITIALIZE 3D GALAXY BACKGROUND
    function initializeGalaxyBackground() {
      // Set up Three.js scene
      const container = document.getElementById('galaxy-background');
      const scene = new THREE.Scene();
      
      // Setup camera
      const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 3000);
      camera.position.z = 1000;
      camera.position.y = 0;
      
      // Setup renderer
      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio > 1 ? 2 : 1);
      container.appendChild(renderer.domElement);
      
      // Create star materials
      const starsMaterial = new THREE.PointsMaterial({
        color: 0xffffff,
        size: 1.5,
        transparent: true,
        opacity: 0.8,
        sizeAttenuation: true
      });
      
      // Distant stars (small)
      const starsGeometry = new THREE.BufferGeometry();
      const starsCount = 3000;
      const starsPositions = new Float32Array(starsCount * 3);
      
      for (let i = 0; i < starsCount; i++) {
        const i3 = i * 3;
        starsPositions[i3] = (Math.random() - 0.5) * 3000;
        starsPositions[i3 + 1] = (Math.random() - 0.5) * 3000;
        starsPositions[i3 + 2] = (Math.random() - 0.5) * 3000;
      }
      
      starsGeometry.setAttribute('position', new THREE.BufferAttribute(starsPositions, 3));
      const starsMesh = new THREE.Points(starsGeometry, starsMaterial);
      scene.add(starsMesh);
      
      // Create larger, brighter stars
      const brightStarsMaterial = new THREE.PointsMaterial({
        color: 0x4f7cff,
        size: 3,
        transparent: true,
        opacity: 1,
        sizeAttenuation: true
      });
      
      const brightStarsGeometry = new THREE.BufferGeometry();
      const brightStarsCount = 100;
      const brightStarsPositions = new Float32Array(brightStarsCount * 3);
      
      for (let i = 0; i < brightStarsCount; i++) {
        const i3 = i * 3;
        brightStarsPositions[i3] = (Math.random() - 0.5) * 2000;
        brightStarsPositions[i3 + 1] = (Math.random() - 0.5) * 2000;
        brightStarsPositions[i3 + 2] = (Math.random() - 0.5) * 2000;
      }
      
      brightStarsGeometry.setAttribute('position', new THREE.BufferAttribute(brightStarsPositions, 3));
      const brightStarsMesh = new THREE.Points(brightStarsGeometry, brightStarsMaterial);
      scene.add(brightStarsMesh);
      
      // Create nebula effect using particle system
      const nebulaGeometry = new THREE.BufferGeometry();
      const nebulaCount = 1000;
      const nebulaPositions = new Float32Array(nebulaCount * 3);
      const nebulaSizes = new Float32Array(nebulaCount);
      const nebulaColors = new Float32Array(nebulaCount * 3);
      
      for (let i = 0; i < nebulaCount; i++) {
        const i3 = i * 3;
        const radius = 300 + Math.random() * 300;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.random() * Math.PI;
        
        // Calculate position on a sphere
        nebulaPositions[i3] = radius * Math.sin(phi) * Math.cos(theta);
        nebulaPositions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
        nebulaPositions[i3 + 2] = radius * Math.cos(phi);
        
        // Random size
        nebulaSizes[i] = 5 + Math.random() * 15;
        
        // Color variation (blues and purples)
        const colorChoice = Math.random();
        if (colorChoice < 0.6) {
          // Blue tones
          nebulaColors[i3] = 0.2 + Math.random() * 0.2;
          nebulaColors[i3 + 1] = 0.4 + Math.random() * 0.3;
          nebulaColors[i3 + 2] = 0.7 + Math.random() * 0.3;
        } else {
          // Purple tones
          nebulaColors[i3] = 0.5 + Math.random() * 0.3;
          nebulaColors[i3 + 1] = 0.2 + Math.random() * 0.2;
          nebulaColors[i3 + 2] = 0.7 + Math.random() * 0.3;
        }
      }
      
      nebulaGeometry.setAttribute('position', new THREE.BufferAttribute(nebulaPositions, 3));
      nebulaGeometry.setAttribute('color', new THREE.BufferAttribute(nebulaColors, 3));
      nebulaGeometry.setAttribute('size', new THREE.BufferAttribute(nebulaSizes, 1));
      
      const nebulaMaterial = new THREE.ShaderMaterial({
        uniforms: {
          time: { value: 0 },
          pointSize: { value: 5.0 }
        },
        vertexShader: `
          attribute float size;
          attribute vec3 color;
          varying vec3 vColor;
          uniform float time;
          void main() {
            vColor = color;
            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
            gl_PointSize = size * (300.0 / -mvPosition.z);
            gl_Position = projectionMatrix * mvPosition;
          }
        `,
        fragmentShader: `
          varying vec3 vColor;
          void main() {
            float dist = length(gl_PointCoord - vec2(0.5));
            if (dist > 0.5) discard;
            gl_FragColor = vec4(vColor, 1.0 - (dist * 2.0));
          }
        `,
        transparent: true,
        depthWrite: false,
        blending: THREE.AdditiveBlending
      });
      
      const nebulaMesh = new THREE.Points(nebulaGeometry, nebulaMaterial);
      scene.add(nebulaMesh);
      
      // Interactive elements - move on mouse movement
      let mouseX = 0;
      let mouseY = 0;
      let targetX = 0;
      let targetY = 0;
      
      document.addEventListener('mousemove', (event) => {
        mouseX = (event.clientX - window.innerWidth / 2) / 100;
        mouseY = (event.clientY - window.innerHeight / 2) / 100;
      });
      
      // Handle window resize
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
      
      // Animation loop
      let lastTime = 0;
      const animate = (time) => {
        const delta = time - lastTime;
        lastTime = time;
        
        targetX = mouseX * 0.5;
        targetY = mouseY * 0.5;
        
        camera.position.x += (targetX - camera.position.x) * 0.05;
        camera.position.y += (-targetY - camera.position.y) * 0.05;
        camera.lookAt(scene.position);
        
        // Rotate star systems
        starsMesh.rotation.y += 0.0001 * delta;
        brightStarsMesh.rotation.y += 0.00015 * delta;
        nebulaMesh.rotation.y += 0.00005 * delta;
        
        // Update nebula time uniform
        nebulaMaterial.uniforms.time.value = time * 0.001;
        
        renderer.render(scene, camera);
        requestAnimationFrame(animate);
      };
      
      animate(0);
    }
    
    // 3. INITIALIZE REALITY MATRIX
    function initializeRealityMatrix() {
      const slider = document.getElementById('matrix-slider');
      const matrix = document.querySelector('.matrix-grid');
      let isDragging = false;
      
      const updateSliderPosition = (e) => {
        let position;
        
        // Check if it's horizontal or vertical layout
        if (window.innerWidth > 992) {
          // Horizontal slider
          position = e.clientX - matrix.getBoundingClientRect().left;
          position = Math.max(100, Math.min(position, matrix.offsetWidth - 100));
          slider.style.left = position + 'px';
          
          // Update grid layout
          document.querySelector('.expectation').style.width = position + 'px';
          document.querySelector('.transformation').style.width = (matrix.offsetWidth - position) + 'px';
        } else {
          // Vertical slider
          position = e.clientY - matrix.getBoundingClientRect().top;
          position = Math.max(100, Math.min(position, matrix.offsetHeight - 100));
          slider.style.top = position + 'px';
          
          // Update grid layout
          document.querySelector('.expectation').style.height = position + 'px';
          document.querySelector('.transformation').style.height = (matrix.offsetHeight - position) + 'px';
        }
      };
      
      // Initialize slider position
      if (window.innerWidth > 992) {
        slider.style.left = '50%';
      } else {
        slider.style.top = '50%';
      }
      
      // Event handlers
      slider.addEventListener('mousedown', () => {
        isDragging = true;
      });
      
      document.addEventListener('mousemove', (e) => {
        if (isDragging) {
          updateSliderPosition(e);
        }
      });
      
      document.addEventListener('mouseup', () => {
        isDragging = false;
      });
      
      // Touch support
      slider.addEventListener('touchstart', () => {
        isDragging = true;
      });
      
      document.addEventListener('touchmove', (e) => {
        if (isDragging) {
          updateSliderPosition(e.touches[0]);
        }
      });
      
      document.addEventListener('touchend', () => {
        isDragging = false;
      });
      
      // Handle window resize
      window.addEventListener('resize', () => {
        // Reset slider position
        if (window.innerWidth > 992) {
          slider.style.left = '50%';
          slider.style.top = '';
          document.querySelector('.expectation').style.width = '';
          document.querySelector('.expectation').style.height = '';
          document.querySelector('.transformation').style.width = '';
          document.querySelector('.transformation').style.height = '';
        } else {
          slider.style.top = '50%';
          slider.style.left = '';
          document.querySelector('.expectation').style.width = '';
          document.querySelector('.expectation').style.height = '';
          document.querySelector('.transformation').style.width = '';
          document.querySelector('.transformation').style.height = '';
        }
      });
    }
    
    // 4. INITIALIZE QUANTUM APPROACH CUBE
    function initializeApproachCube() {
      const cube = document.getElementById('approach-cube');
      if (!cube) return;
      
      const cubeButtons = document.querySelectorAll('.cube-btn');
      
      // Current face and rotation
      let currentFace = 'front';
      
      // Set cube transforms for each face
      const cubeRotations = {
        'front': 'rotateY(0deg) rotateX(0deg)',
        'back': 'rotateY(180deg) rotateX(0deg)',
        'right': 'rotateY(90deg) rotateX(0deg)',
        'left': 'rotateY(-90deg) rotateX(0deg)',
        'top': 'rotateX(-90deg) rotateY(0deg)',
        'bottom': 'rotateX(90deg) rotateY(0deg)'
      };
      
      // Update cube rotation
      const rotateCube = (face) => {
        cube.style.transform = cubeRotations[face];
        currentFace = face;
        
        // Update active button
        cubeButtons.forEach(btn => {
          if (btn.dataset.face === face) {
            btn.classList.add('active');
          } else {
            btn.classList.remove('active');
          }
        });
      };
      
      // Set initial state
      rotateCube('front');
      
      // Add click handlers to buttons
      cubeButtons.forEach(btn => {
        btn.addEventListener('click', () => {
          rotateCube(btn.dataset.face);
        });
      });
      
      // Auto-rotate cube every 10 seconds if no interaction
      let autoRotateTimer;
      
      const startAutoRotate = () => {
        autoRotateTimer = setInterval(() => {
          const faces = ['front', 'right', 'back', 'left', 'top', 'bottom'];
          const currentIndex = faces.indexOf(currentFace);
          const nextIndex = (currentIndex + 1) % faces.length;
          rotateCube(faces[nextIndex]);
        }, 10000);
      };
      
      // Start auto-rotation after a delay
      setTimeout(startAutoRotate, 5000);
      
      // Pause auto-rotation on user interaction
      cubeButtons.forEach(btn => {
        btn.addEventListener('click', () => {
          clearInterval(autoRotateTimer);
          // Restart auto-rotation after 30 seconds of inactivity
          setTimeout(startAutoRotate, 30000);
        });
      });
    }
    
    // 5. INITIALIZE SUCCESS ECOSYSTEM MAP - MOBILE-OPTIMIZED
    function initializeEcosystem() {
      const canvas = document.getElementById('ecosystem-canvas');
      const tooltip = document.getElementById('ecosystem-tooltip');
      
      if (!canvas) return;
      
      const ctx = canvas.getContext('2d');
      const isMobile = window.innerWidth < 768;
      
      // Set canvas size
      const resizeCanvas = () => {
        canvas.width = canvas.parentElement.clientWidth;
        canvas.height = canvas.parentElement.clientHeight;
      };
      
      resizeCanvas();
      window.addEventListener('resize', resizeCanvas);
      
      // Node data - simplified for mobile if needed
      const nodes = [
        { id: 1, type: 'system', name: 'Customer Acquisition Engine', desc: 'Automated lead generation and qualification system', x: 0, y: 0, radius: isMobile ? 32 : 40, color: '#4f7cff' },
        { id: 2, type: 'system', name: 'Conversion Optimization System', desc: 'Machine learning-driven conversion rate optimization', x: 0, y: 0, radius: isMobile ? 30 : 38, color: '#4f7cff' },
        { id: 3, type: 'system', name: 'Retention Architecture', desc: 'Predictive analytics for customer retention and growth', x: 0, y: 0, radius: isMobile ? 28 : 36, color: '#4f7cff' },
        { id: 4, type: 'client', name: 'TechCorp Global', desc: '217% revenue increase over 18 months', x: 0, y: 0, radius: isMobile ? 24 : 30, color: '#ff4f7c' },
        { id: 5, type: 'client', name: 'FinServe Solutions', desc: '412% ROI on growth systems investment', x: 0, y: 0, radius: isMobile ? 26 : 32, color: '#ff4f7c' },
        { id: 6, type: 'client', name: 'MedTech Innovations', desc: 'Reduced CAC by 37% while scaling 3x', x: 0, y: 0, radius: isMobile ? 22 : 28, color: '#ff4f7c' },
        { id: 7, type: 'methodology', name: 'Growth Architecture Framework', desc: 'Our proprietary system for building scalable growth', x: 0, y: 0, radius: isMobile ? 28 : 35, color: '#4CAF50' },
        { id: 8, type: 'methodology', name: 'Data Unification Protocol', desc: 'Method for connecting disparate data sources', x: 0, y: 0, radius: isMobile ? 26 : 32, color: '#4CAF50' },
        { id: 9, type: 'methodology', name: 'Cognitive Revenue System', desc: 'AI-driven approach to revenue optimization', x: 0, y: 0, radius: isMobile ? 27 : 33, color: '#4CAF50' },
        { id: 10, type: 'technology', name: 'Predictive Analytics Engine', desc: 'Custom machine learning models for growth forecasting', x: 0, y: 0, radius: isMobile ? 28 : 34, color: '#FF9800' },
        { id: 11, type: 'technology', name: 'Behavioral Intelligence Platform', desc: 'Customer behavior analysis and prediction system', x: 0, y: 0, radius: isMobile ? 25 : 31, color: '#FF9800' },
        { id: 12, type: 'technology', name: 'Autonomous Optimization Tool', desc: 'Self-learning system for continuous performance improvement', x: 0, y: 0, radius: isMobile ? 27 : 33, color: '#FF9800' }
      ];
      
      // Connection data - can be simplified for mobile
      const connections = [
        { source: 1, target: 4 },
        { source: 1, target: 5 },
        { source: 1, target: 6 },
        { source: 2, target: 4 },
        { source: 2, target: 5 },
        { source: 3, target: 4 },
        { source: 3, target: 6 },
        { source: 7, target: 1 },
        { source: 7, target: 2 },
        { source: 7, target: 3 },
        { source: 8, target: 1 },
        { source: 8, target: 11 },
        { source: 9, target: 2 },
        { source: 9, target: 3 },
        { source: 10, target: 1 },
        { source: 10, target: 9 },
        { source: 11, target: 2 },
        { source: 11, target: 9 },
        { source: 12, target: 2 },
        { source: 12, target: 3 }
      ];
      
      // Physics simulation variables
      let simulation = {
        nodes: [],
        links: []
      };
      
      // Initialize node positions in a circle
      const initializePositions = () => {
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const radius = Math.min(canvas.width, canvas.height) * (isMobile ? 0.30 : 0.35);
        
        nodes.forEach((node, i) => {
          const angle = (i / nodes.length) * Math.PI * 2;
          node.x = centerX + Math.cos(angle) * radius;
          node.y = centerY + Math.sin(angle) * radius;
          
          // Add physics properties
          simulation.nodes.push({
            id: node.id,
            x: node.x,
            y: node.y,
            vx: 0,
            vy: 0
          });
        });
        
        // Create links for physics simulation
        connections.forEach(conn => {
          simulation.links.push({
            source: simulation.nodes.find(n => n.id === conn.source),
            target: simulation.nodes.find(n => n.id === conn.target),
            distance: isMobile ? 120 : 150
          });
        });
      };
      
      initializePositions();
      
    // Simple force-directed layout
const updateSimulation = () => {
  // OPTIMIZATION: Less frequent updates on mobile
  if (isMobile && Math.random() > 0.7) return; // Only update 70% of frames on mobile
  
  // Apply forces
  
  // Repulsion between nodes - stronger on mobile
  const repulsionStrength = isMobile ? 2500 : 2000;
  
  for (let i = 0; i < simulation.nodes.length; i++) {
    const nodeA = simulation.nodes[i];
    
          
          for (let j = i + 1; j < simulation.nodes.length; j++) {
            const nodeB = simulation.nodes[j];
            
            const dx = nodeB.x - nodeA.x;
            const dy = nodeB.y - nodeA.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance > 0) {
              const repulsionForce = repulsionStrength / (distance * distance);
              const forceX = dx / distance * repulsionForce;
              const forceY = dy / distance * repulsionForce;
              
              nodeA.vx -= forceX;
              nodeA.vy -= forceY;
              nodeB.vx += forceX;
              nodeB.vy += forceY;
            }
          }
        }
        
        // Attraction along links
        simulation.links.forEach(link => {
          const dx = link.target.x - link.source.x;
          const dy = link.target.y - link.source.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance > 0) {
            const attractionForce = (distance - link.distance) * (isMobile ? 0.06 : 0.05);
            const forceX = dx / distance * attractionForce;
            const forceY = dy / distance * attractionForce;
            
            link.source.vx += forceX;
            link.source.vy += forceY;
            link.target.vx -= forceX;
            link.target.vy -= forceY;
          }
        });
        
        // Center gravity - stronger on mobile
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const gravityStrength = isMobile ? 0.015 : 0.01;
        
        simulation.nodes.forEach(node => {
          const dx = centerX - node.x;
          const dy = centerY - node.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance > 0) {
            const gravityForce = distance * gravityStrength;
            node.vx += dx / distance * gravityForce;
            node.vy += dy / distance * gravityForce;
          }
        });
        
        // Update positions
        simulation.nodes.forEach(node => {
          // Apply velocity
          node.x += node.vx;
          node.y += node.vy;
          
          // Damping
          node.vx *= 0.9;
          node.vy *= 0.9;
          
          // Boundary constraints - tighter on mobile
          const padding = isMobile ? 40 : 50;
          
          if (node.x < padding) {
            node.x = padding;
            node.vx = -node.vx * 0.5;
          }
          
          if (node.x > canvas.width - padding) {
            node.x = canvas.width - padding;
            node.vx = -node.vx * 0.5;
          }
          
          if (node.y < padding) {
            node.y = padding;
            node.vy = -node.vy * 0.5;
          }
          
          if (node.y > canvas.height - padding) {
            node.y = canvas.height - padding;
            node.vy = -node.vy * 0.5;
          }
          
          // Update actual node
          const actualNode = nodes.find(n => n.id === node.id);
          actualNode.x = node.x;
          actualNode.y = node.y;
        });
      };
      
      // Draw the ecosystem
      const drawEcosystem = () => {
        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Draw connections
        connections.forEach(conn => {
          const sourceNode = nodes.find(n => n.id === conn.source);
          const targetNode = nodes.find(n => n.id === conn.target);
          
          // Calculate connection gradient color
          const gradient = ctx.createLinearGradient(
            sourceNode.x, sourceNode.y,
            targetNode.x, targetNode.y
          );
          
          gradient.addColorStop(0, sourceNode.color);
          gradient.addColorStop(1, targetNode.color);
          
          ctx.beginPath();
          ctx.moveTo(sourceNode.x, sourceNode.y);
          ctx.lineTo(targetNode.x, targetNode.y);
          ctx.strokeStyle = gradient;
          ctx.lineWidth = isMobile ? 3 : 2; // Thicker lines on mobile
          ctx.globalAlpha = 0.6;
          ctx.stroke();
          ctx.globalAlpha = 1;
        });
        
        // Draw nodes
        nodes.forEach(node => {
          // Draw node circle
          ctx.beginPath();
          ctx.arc(node.x, node.y, node.radius, 0, Math.PI * 2);
          
          // Create radial gradient
          const gradient = ctx.createRadialGradient(
            node.x, node.y, 0,
            node.x, node.y, node.radius
          );
          
          const color = node.color;
          gradient.addColorStop(0, color);
          gradient.addColorStop(1, color + '80'); // Add alpha
          
          ctx.fillStyle = gradient;
          ctx.fill();
          
          // Draw border
          ctx.strokeStyle = '#fff';
          ctx.lineWidth = 2;
          ctx.globalAlpha = 0.3;
          ctx.stroke();
          ctx.globalAlpha = 1;
          
          // Draw node name - larger font on mobile
          const fontSize = isMobile ? 14 : 12;
          ctx.font = `${fontSize}px Inter`;
          ctx.fillStyle = '#fff';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          
          // Wrap text - simpler on mobile
          const words = node.name.split(' ');
          const maxWidth = node.radius * (isMobile ? 1.8 : 1.5);
          let line = '';
          let lines = [];
          let lineHeight = fontSize + 2;
          
          for (let i = 0; i < words.length; i++) {
            const testLine = line + words[i] + ' ';
            
            if (ctx.measureText(testLine).width > maxWidth) {
              lines.push(line);
              line = words[i] + ' ';
            } else {
              line = testLine;
            }
          }
          
          lines.push(line);
          
          // Limit to 2 lines on mobile
          if (isMobile && lines.length > 2) {
            lines = lines.slice(0, 2);
            lines[1] = lines[1].trim() + '...';
          }
          
          for (let i = 0; i < lines.length; i++) {
            ctx.fillText(
              lines[i],
              node.x,
              node.y - ((lines.length - 1) * lineHeight / 2) + (i * lineHeight)
            );
          }
        });
      };
      
      // Interactive elements - special handling for mobile
      let hoveredNode = null;
      let activeNode = null; // For mobile "selected" state
      
      // Function to get distance between points
      const getDistance = (x1, y1, x2, y2) => {
        return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
      };
      
      // Check if a point is inside a node
      const getNodeAtPosition = (x, y) => {
        for (let i = nodes.length - 1; i >= 0; i--) {
          const node = nodes[i];
          const distance = getDistance(x, y, node.x, node.y);
          
          if (distance <= node.radius) {
            return node;
          }
        }
        return null;
      };
      
      // Show tooltip
      const showTooltip = (node, x, y) => {
        if (!tooltip) return;
        
        tooltip.style.opacity = '1';
        tooltip.innerHTML = `<h4>${node.name}</h4><p>${node.desc}</p>`;
        
        // Position the tooltip
        const tooltipWidth = 300;
        const viewportWidth = window.innerWidth;
        
        if (x + tooltipWidth + 20 > viewportWidth) {
          tooltip.style.left = (x - tooltipWidth - 10) + 'px';
        } else {
          tooltip.style.left = (x + 20) + 'px';
        }
        
        tooltip.style.top = y + 'px';
      };
      
      // Hide tooltip
      const hideTooltip = () => {
        if (tooltip) {
          tooltip.style.opacity = '0';
        }
      };
      
      if (isMobile) {
  // Set touch-action on the canvas element directly
  canvas.style.touchAction = "none";
  
  // Simplify touch handling with direct approach
  let draggedNode = null;
  
  canvas.addEventListener('touchstart', function(event) {
    // Explicitly prevent default behavior
    event.preventDefault();
    event.stopPropagation();
    
    const rect = canvas.getBoundingClientRect();
    const touchX = event.touches[0].clientX - rect.left;
    const touchY = event.touches[0].clientY - rect.top;
    
    // Find node under touch
    draggedNode = getNodeAtPosition(touchX, touchY);
    
    if (draggedNode) {
      // Show tooltip
      showTooltip(draggedNode, event.touches[0].clientX, event.touches[0].clientY - 60);
    }
  }, { passive: false });
  
  canvas.addEventListener('touchmove', function(event) {
    // Explicitly prevent default behavior
    event.preventDefault();
    event.stopPropagation();
    
    if (!draggedNode) return;
    
    const rect = canvas.getBoundingClientRect();
    const touchX = event.touches[0].clientX - rect.left;
    const touchY = event.touches[0].clientY - rect.top;
    
    // Move the node directly
    const simNode = simulation.nodes.find(n => n.id === draggedNode.id);
    if (simNode) {
      simNode.x = touchX;
      simNode.y = touchY;
      simNode.vx = 0;
      simNode.vy = 0;
    }
    
    // Update tooltip position
    if (tooltip) {
      tooltip.style.left = (event.touches[0].clientX + 15) + 'px';
      tooltip.style.top = (event.touches[0].clientY - 60) + 'px';
    }
  }, { passive: false });
  
  canvas.addEventListener('touchend', function(event) {
    // Explicitly prevent default behavior
    event.preventDefault();
    event.stopPropagation();
    
    // Release node on touch end
    draggedNode = null;
  }, { passive: false });
  
  // Add visual indicator for touch interaction
  const touchIndicator = document.createElement('div');
  touchIndicator.style.position = 'absolute';
  touchIndicator.style.bottom = '10px';
  touchIndicator.style.left = '0';
  touchIndicator.style.width = '100%';
  touchIndicator.style.textAlign = 'center';
  touchIndicator.style.fontSize = '14px';
  touchIndicator.style.color = '#fff';
  touchIndicator.style.padding = '8px';
  touchIndicator.style.background = 'rgba(0,0,0,0.5)';
  touchIndicator.style.zIndex = '1000';
  touchIndicator.innerText = 'Tap nodes to view info • Touch and drag to move';
  
  canvas.parentElement.appendChild(touchIndicator);
} else {
        // DESKTOP behavior
        canvas.addEventListener('mousemove', (e) => {
          const rect = canvas.getBoundingClientRect();
          const mouseX = e.clientX - rect.left;
          const mouseY = e.clientY - rect.top;
          
          // Check for node hover
          const newHoveredNode = getNodeAtPosition(mouseX, mouseY);
          
          if (newHoveredNode) {
            canvas.style.cursor = 'pointer';
            
            // Only update if hovering over a new node
            if (hoveredNode !== newHoveredNode) {
              hoveredNode = newHoveredNode;
              showTooltip(hoveredNode, e.clientX, e.clientY);
            }
          } else {
            canvas.style.cursor = 'default';
            
            // Only hide tooltip if not hovering any node
            if (hoveredNode !== null) {
              hoveredNode = null;
              hideTooltip();
            }
          }
        });
        
        canvas.addEventListener('mouseleave', () => {
          hoveredNode = null;
          hideTooltip();
        });
        
        // Dragging support
        let isDragging = false;
        let draggedNode = null;
        
        canvas.addEventListener('mousedown', (e) => {
          const rect = canvas.getBoundingClientRect();
          const mouseX = e.clientX - rect.left;
          const mouseY = e.clientY - rect.top;
          
          draggedNode = getNodeAtPosition(mouseX, mouseY);
          if (draggedNode) {
            isDragging = true;
            canvas.style.cursor = 'grabbing';
          }
        });
        
        canvas.addEventListener('mouseup', () => {
          isDragging = false;
          draggedNode = null;
          canvas.style.cursor = hoveredNode ? 'pointer' : 'default';
        });
        
        canvas.addEventListener('mousemove', (e) => {
          if (isDragging && draggedNode) {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            // Update node position
            const simNode = simulation.nodes.find(n => n.id === draggedNode.id);
            if (simNode) {
              simNode.x = mouseX;
              simNode.y = mouseY;
              simNode.vx = 0;
              simNode.vy = 0;
            }
          }
        });
      }
      
      // Animation loop
      const animate = () => {
        updateSimulation();
        drawEcosystem();
        requestAnimationFrame(animate);
      };
      
      animate();
    }
    
    function initializeArtifactGallery() {
  // Set up Three.js scene
  const container = document.getElementById('artifact-scene');
  if (!container) return;
  
  const scene = new THREE.Scene();
  
  // Setup camera
  const camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 1000);
  camera.position.z = 5;
  
  // Setup renderer
  const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setSize(container.clientWidth, container.clientHeight);
  container.appendChild(renderer.domElement);
  
  // Apply critical fixes for mobile touch
  renderer.domElement.style.touchAction = "none";
  
  // Create artifacts
  const artifacts = [
    {
      name: 'The Quantum Compass',
      description: 'This artifact represents our commitment to direction over location. In growth, knowing which way to move matters more than where you currently stand. The compass reminds us that progress isn\'t always linear but requires constant orientation toward true north: sustainable growth.',
      geometry: new THREE.TorusGeometry(1, 0.3, 16, 50),
      color: 0x4f7cff,
      position: { x: 0, y: 0, z: 0 }
    },
    {
      name: 'The Infinite Loop',
      description: 'This Möbius strip symbolizes our iterative approach to growth. There is no endpoint - only continuous improvement, learning, and evolution. The single-sided surface reminds us that measurement and action are part of the same continuous process.',
      geometry: new THREE.TorusKnotGeometry(0.8, 0.2, 100, 16),
      color: 0xff4f7c,
      position: { x: -3, y: 0, z: -2 }
    },
    {
      name: 'The Crystal Node',
      description: 'This multi-faceted crystal represents how we connect disparate data points to reveal hidden patterns and opportunities. Each face reflects light differently, just as each data point offers a unique perspective on customer behavior and business performance.',
      geometry: new THREE.IcosahedronGeometry(1, 0),
      color: 0x4CAF50,
      position: { x: 3, y: 0, z: -2 }
    },
    {
      name: 'The Quantum Cube',
      description: 'This cube exists in multiple states simultaneously, representing our ability to test and validate multiple strategies in parallel. The superposition principle reminds us that we must measure to know, but we can explore numerous possibilities before committing.',
      geometry: new THREE.BoxGeometry(1.2, 1.2, 1.2),
      color: 0xFF9800,
      position: { x: -2, y: 2, z: -3 }
    },
    {
      name: 'The Singularity Sphere',
      description: 'This perfect sphere represents our pursuit of simplicity on the far side of complexity. Within chaotic markets and noisy data, we find elegant, unified solutions. The sphere has the lowest surface area for its volume - maximum efficiency with minimum complexity.',
      geometry: new THREE.SphereGeometry(1, 32, 32),
      color: 0x6a92ff,
      position: { x: 2, y: -2, z: -3 }
    }
  ];
  
  // Create mesh objects
  const meshes = [];
  artifacts.forEach(artifact => {
    const material = new THREE.MeshPhongMaterial({
      color: artifact.color,
      specular: 0xffffff,
      shininess: 100
    });
    
    const mesh = new THREE.Mesh(artifact.geometry, material);
    mesh.position.set(artifact.position.x, artifact.position.y, artifact.position.z);
    mesh.userData.name = artifact.name;
    mesh.userData.description = artifact.description;
    
    scene.add(mesh);
    meshes.push(mesh);
  });
  
  // Add lights
  const ambientLight = new THREE.AmbientLight(0x404040, 1);
  scene.add(ambientLight);
  
  const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
  directionalLight.position.set(5, 5, 5);
  scene.add(directionalLight);
  
  const pointLight = new THREE.PointLight(0x4f7cff, 2, 20);
  pointLight.position.set(5, 0, 0);
  scene.add(pointLight);
  
  // Get the info panel and reposition it - THIS MAY BE THE KEY FIX
  const artifactInfo = document.getElementById('artifact-info');
  
  // Reposition info panel outside the gallery container
  if (artifactInfo) {
    // Move the info panel out of the container if it's inside
    if (artifactInfo.parentElement === container) {
      container.parentElement.appendChild(artifactInfo);
    }
    
    // Style it to appear at the bottom of the screen
    artifactInfo.style.position = 'absolute';
    artifactInfo.style.bottom = '20px';
    artifactInfo.style.left = '50%';
    artifactInfo.style.transform = 'translateX(-50%)';
    artifactInfo.style.maxWidth = '90%';
    artifactInfo.style.zIndex = '1000';
    artifactInfo.style.pointerEvents = 'auto'; // Ensure this doesn't block events
  }
  
  // Raycaster for interaction
  const raycaster = new THREE.Raycaster();
  const pointer = new THREE.Vector2();
  
  // Selected artifact tracking
  let selectedArtifact = null;
  
  // Function to select an artifact
  const selectArtifact = (mesh) => {
    // Reset previous selection
    if (selectedArtifact) {
      selectedArtifact.material.emissive.set(0x000000);
    }
    
    // Set new selection
    if (mesh) {
      selectedArtifact = mesh;
      selectedArtifact.material.emissive.set(0x333333);
      
      // Update info panel
      if (artifactInfo) {
        artifactInfo.innerHTML = `
          <h3 class="artifact-name">${mesh.userData.name}</h3>
          <p class="artifact-description">${mesh.userData.description}</p>
          <button class="info-close-btn" style="position:absolute;top:10px;right:10px;background:none;border:none;color:white;font-size:18px;cursor:pointer;">
            <i class="fas fa-times"></i>
          </button>
        `;
        
        // Add close button functionality
        const closeBtn = artifactInfo.querySelector('.info-close-btn');
        if (closeBtn) {
          closeBtn.addEventListener('click', () => {
            artifactInfo.classList.remove('active');
            selectedArtifact.material.emissive.set(0x000000);
            selectedArtifact = null;
          });
        }
        
        artifactInfo.classList.add('active');
      }
    } else {
      selectedArtifact = null;
      if (artifactInfo) {
        artifactInfo.classList.remove('active');
      }
    }
  };
  
  // Interaction variables
  let isDragging = false;
  let previousX = 0;
  let previousY = 0;
  
  // Check if mobile
  const isMobile = window.innerWidth < 768;
  
  // Universal touch/mouse event handlers
  const onStart = (clientX, clientY) => {
    isDragging = false;
    previousX = clientX;
    previousY = clientY;
  };
  
  const onMove = (clientX, clientY) => {
    const deltaX = clientX - previousX;
    const deltaY = clientY - previousY;
    
    // If moved a significant amount, consider it dragging
    if (Math.abs(deltaX) > 5 || Math.abs(deltaY) > 5) {
      isDragging = true;
      
      // Rotate scene
      scene.rotation.y += deltaX * 0.01;
      scene.rotation.x += deltaY * 0.01;
    }
    
    previousX = clientX;
    previousY = clientY;
  };
  
  const onEnd = (clientX, clientY, rect) => {
    // If not dragging, check for object selection
    if (!isDragging) {
      // Calculate normalized position
      pointer.x = ((clientX - rect.left) / rect.width) * 2 - 1;
      pointer.y = -((clientY - rect.top) / rect.height) * 2 + 1;
      
      // Perform raycasting
      raycaster.setFromCamera(pointer, camera);
      const intersects = raycaster.intersectObjects(meshes);
      
      if (intersects.length > 0) {
        selectArtifact(intersects[0].object);
      } else {
        selectArtifact(null);
      }
    }
  };
  
  // Mobile event handlers
  if (isMobile) {
    renderer.domElement.addEventListener('touchstart', (e) => {
      e.preventDefault();
      if (e.touches.length === 1) {
        onStart(e.touches[0].clientX, e.touches[0].clientY);
      }
    }, { passive: false });
    
    renderer.domElement.addEventListener('touchmove', (e) => {
      e.preventDefault();
      if (e.touches.length === 1) {
        onMove(e.touches[0].clientX, e.touches[0].clientY);
      }
    }, { passive: false });
    
    renderer.domElement.addEventListener('touchend', (e) => {
      e.preventDefault();
      if (e.changedTouches.length === 1) {
        const rect = renderer.domElement.getBoundingClientRect();
        onEnd(e.changedTouches[0].clientX, e.changedTouches[0].clientY, rect);
      }
    }, { passive: false });
  }
  // Desktop event handlers
  else {
    let isMouseDown = false;
    
    renderer.domElement.addEventListener('mousedown', (e) => {
      isMouseDown = true;
      onStart(e.clientX, e.clientY);
      renderer.domElement.style.cursor = 'grabbing';
    });
    
    renderer.domElement.addEventListener('mousemove', (e) => {
      // Update cursor for hover
      const rect = renderer.domElement.getBoundingClientRect();
      pointer.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
      pointer.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
      
      raycaster.setFromCamera(pointer, camera);
      const intersects = raycaster.intersectObjects(meshes);
      
      if (intersects.length > 0) {
        renderer.domElement.style.cursor = 'pointer';
      } else {
        renderer.domElement.style.cursor = isMouseDown ? 'grabbing' : 'grab';
      }
      
      // Handle dragging
      if (isMouseDown) {
        onMove(e.clientX, e.clientY);
      }
    });
    
    renderer.domElement.addEventListener('mouseup', (e) => {
      if (isMouseDown) {
        const rect = renderer.domElement.getBoundingClientRect();
        onEnd(e.clientX, e.clientY, rect);
      }
      
      isMouseDown = false;
      renderer.domElement.style.cursor = 'grab';
    });
    
    renderer.domElement.addEventListener('mouseleave', () => {
      isMouseDown = false;
      renderer.domElement.style.cursor = 'grab';
    });
    
    renderer.domElement.addEventListener('dblclick', () => {
      scene.rotation.set(0, 0, 0);
    });
  }
  
  // Handle window resize
  window.addEventListener('resize', () => {
    camera.aspect = container.clientWidth / container.clientHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(container.clientWidth, container.clientHeight);
  });
  
  // Animation loop
  function animate() {
    requestAnimationFrame(animate);
    
    // Rotate artifacts
    meshes.forEach(mesh => {
      mesh.rotation.y += 0.003;
      mesh.rotation.x += 0.002;
    });
    
    renderer.render(scene, camera);
  }
  
  animate();
}
  </script>
</body>
</html>